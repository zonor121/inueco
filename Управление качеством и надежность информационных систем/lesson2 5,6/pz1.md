## Практическое задание

### Практическое задание

**Тема:** модульное тестирование в Python с использованием `unittest`
(setUp / tearDown, тестирование исключений, `subTest`, `unittest.mock`)

### Цель

* Реализовать модуль с бизнес-логикой и покрыть его модульными тестами.
* Освоить написание тестов на `unittest` с использованием:

  * подготовки и очистки данных,
  * проверки исключений,
  * параметризации повторяющихся проверок,
  * подмены зависимостей через `unittest.mock`.

### Задание (шаги)

#### Шаг 1. Создайте файл `order_service.py`

Реализуйте мини-сервис оформления заказа.

1. **Исключения**

* `InvalidItemError`
* `EmptyCartError`
* `PaymentError`

2. **Класс**

```python
class OrderService:
    ...
```

Методы:

* `add_item(name: str, price: int) -> None`

  * `name` не должен быть пустым (после `strip()`)
  * `price` — целое число, строго больше 0
  * при нарушении условий выбрасывайте `InvalidItemError`

* `apply_discount(code: str) -> None`

  * поддерживаемые промокоды:

    * `"SAVE10"` → скидка 10%
    * `"SAVE20"` → скидка 20%
  * неизвестный код → `ValueError`
  * если корзина пуста → `EmptyCartError`

* `total() -> int`

  * возвращает итоговую стоимость заказа
  * результат должен быть целым числом
  * дробная часть после применения скидки отбрасывается (округление вниз)

* `checkout(payment_gateway) -> str`

  * если корзина пуста → `EmptyCartError`
  * вызывает `payment_gateway.charge(amount: int) -> str`
  * если `charge` выбрасывает любое исключение → `PaymentError`
  * при успехе возвращает строку транзакции, полученную от `charge`

#### Шаг 2. Создайте файл `test_order_service.py`

Напишите модульные тесты с использованием `unittest`.

1. **Проверка валидации товаров**

* пустое имя (`""`, `"   "`) → `InvalidItemError`
* `price <= 0` → `InvalidItemError`
* нецелочисленный `price` (`"10"`, `10.5`) → `InvalidItemError`

2. **Проверка применения скидок**

* `"SAVE10"` и `"SAVE20"` корректно уменьшают итоговую сумму
* неизвестный промокод → `ValueError`
* попытка применить скидку к пустой корзине → `EmptyCartError`

3. **Тестирование исключений в `checkout`**

* вызов `checkout` с пустой корзиной → `EmptyCartError`
* если платёжный шлюз выбрасывает исключение → `PaymentError`

4. **Параметризация через `subTest`**
   В одном тесте проверьте `total()` для нескольких сценариев, например:

* `[("A", 100)]`, без скидки → `100`
* `[("A", 100)]`, `"SAVE10"` → `90`
* `[("A", 99)]`, `"SAVE10"` → `89`
* `[("A", 50), ("B", 70)]`, `"SAVE20"` → `96`

5. **Использование моков**

* замокайте объект `payment_gateway`
* проверьте, что:

  * метод `charge` вызывается **ровно один раз**
  * `charge` вызывается с **корректной суммой**
  * `checkout` возвращает значение, которое вернул `charge`

#### Шаг 3. Запуск тестов

Убедитесь, что тесты запускаются следующими командами:

```bash
python -m unittest -v
```

и

```bash
python -m unittest discover -v
```

### Подсказки по ключевым частям

* Используйте `setUp()` для создания нового экземпляра `OrderService` перед каждым тестом.
* Проверку исключений выполняйте только через `with self.assertRaises(...)`.
* Для повторяющихся проверок используйте `subTest`.
* Для подмены платёжного шлюза используйте `Mock` или `MagicMock`.
* Для симуляции ошибки используйте `side_effect`.

### Что проверить перед отправкой (чек-лист)

* [ ] Все тесты успешно запускаются через `python -m unittest -v`
* [ ] Тесты не зависят от порядка выполнения
* [ ] Исключения проверяются через `assertRaises`
* [ ] Используется минимум один `subTest`
* [ ] Используется `unittest.mock` с проверкой `assert_called_once_with`
* [ ] Названия тестов отражают проверяемое поведение
* [ ] Подготовка данных вынесена в `setUp`

### Советы по улучшению работы

* Вынесите добавление товаров в отдельный вспомогательный метод тестового класса.
* Избегайте дублирования кода внутри тестов.
* Придерживайтесь принципа «один тест — одно поведение».
* Попробуйте расширить логику (например, очистка корзины после успешного `checkout`) и зафиксировать это тестами.

Если потребуется — могу подготовить **эталонное решение**, **скелет проекта** или **вариант задания повышенной сложности**.
