## Практическое задание

### Практическое задание

**Тема:** модульное тестирование в Python с `unittest` (setUp/tearDown, исключения, subTest, unittest.mock)

---

### Цель

* Написать модуль с логикой и покрыть его тестами на `unittest`.
* Научиться проверять: обычные сценарии, ошибки/исключения, повторяющиеся кейсы через `subTest`, зависимости через `unittest.mock`.

---

### Задание (шаги)

#### Шаг 1. Создай файл `order_service.py`

Реализуй мини-сервис заказа.

1. **Исключения**

* `InvalidItemError`
* `EmptyCartError`
* `PaymentError`

2. **Класс**
   `class OrderService:`

Методы:

* `add_item(name: str, price: int) -> None`

  * `name` не пустой (после `.strip()`)
  * `price` — целое число, `price > 0`
  * иначе → `InvalidItemError`

* `apply_discount(code: str) -> None`

  * поддерживаемые промокоды:

    * `"SAVE10"` → скидка 10%
    * `"SAVE20"` → скидка 20%
  * неизвестный код → `ValueError`
  * если корзина пустая → `EmptyCartError` (скидку нельзя применить к пустому заказу)

* `total() -> int`

  * возвращает итоговую стоимость **целым числом**
  * скидка округляется вниз (например, 99 со скидкой 10% → 89)

* `checkout(payment_gateway) -> str`

  * если корзина пустая → `EmptyCartError`
  * вызывает `payment_gateway.charge(amount: int) -> str`
  * если `charge` выбрасывает любое исключение → `PaymentError`
  * если успешно → возвращает строку транзакции (то, что вернул `charge`)

---

#### Шаг 2. Создай файл `test_order_service.py`

Покрой `OrderService` тестами на `unittest`.

1. **Валидация товара**

* пустое имя (`""`, `"   "`) → `InvalidItemError`
* `price <= 0` → `InvalidItemError`
* нецелочисленный `price` (например, `"10"`, `10.5`) → `InvalidItemError`

2. **Скидки**

* `"SAVE10"` и `"SAVE20"` корректно уменьшают сумму
* неизвестный код → `ValueError`
* скидка на пустую корзину → `EmptyCartError`

3. **Исключения в checkout**

* checkout с пустой корзиной → `EmptyCartError`
* если gateway падает (симулируй через mock) → `PaymentError`

4. **Параметризация через `subTest`**
   Сделай таблицу кейсов и в одном тесте проверь `total()` на разных входных данных, например:

* товары: `[("A", 100)]`, скидка: нет → `100`
* товары: `[("A", 100)]`, скидка: `"SAVE10"` → `90`
* товары: `[("A", 99)]`, скидка: `"SAVE10"` → `89`
* товары: `[("A", 50), ("B", 70)]`, скидка: `"SAVE20"` → `96`

5. **Моки**

* используй `unittest.mock.Mock` или `MagicMock`
* проверь, что:

  * `charge` вызван **ровно один раз**
  * `charge` вызван с **правильной суммой**
  * `checkout` возвращает строку, которую вернул `charge`

---

#### Шаг 3. Запуск тестов

Запусти тесты командами:

```bash
python -m unittest -v
```

и

```bash
python -m unittest discover -v
```

---

### Подсказки по ключевым частям

* **setUp:** перед каждым тестом создавай новый `OrderService`.
* **assertRaises:** всегда проверяй исключения через `with self.assertRaises(...)`.
* **subTest:** чтобы видеть, какой именно кейс упал, не останавливая остальные.
* **mock:**

  * успешный платеж: `mock_gateway.charge.return_value = "tx_123"`
  * падение платежа: `mock_gateway.charge.side_effect = RuntimeError("fail")`

---

### Что проверить перед отправкой (чек-лист)

* [ ] Все тесты запускаются через `python -m unittest -v`
* [ ] Тесты не зависят от порядка выполнения
* [ ] Есть тесты на исключения через `assertRaises`
* [ ] Есть минимум 1 тест с `subTest`
* [ ] Есть минимум 1 тест с `unittest.mock` + проверка `assert_called_once_with`
* [ ] Имена тестов читаемые и отражают поведение (`test_checkout_raises_on_empty_cart`)
* [ ] Нет дублирования подготовки данных — она в `setUp`

---

### Советы по улучшению работы

* Вынеси добавление набора товаров в helper-метод в тестах (например, `_add_items(...)`).
* Делай тесты “одно утверждение — одно поведение”.
* Добавь тест на повторное применение скидки (если решишь запретить или переопределять — зафиксируй контракт и тестами).
* Добавь проверку, что после успешного `checkout` корзина очищается (если добавишь такое правило).
