## Практическое задание

**Тема:** первые шаги с `pandas.DataFrame` (после `Series`)
**Формат:** написать код в одном ноутбуке/скрипте (`.ipynb` или `.py`), без чтения файлов — данные создаём в коде.

## Цель

1. Научиться создавать `DataFrame` из словаря списков и из списка словарей.
2. Освоить базовые операции: просмотр, выбор столбцов/строк, фильтрация, создание новых столбцов, простая агрегация и сортировка.
3. Потренировать аккуратность: типы данных, пропуски (`NaN`), проверка результата.

## Задание (шаги)

### 1) Создай данные и `DataFrame`

**Шаг 1.1.** Создай список словарей `students` (минимум 10 строк).
Каждая запись должна содержать поля:

* `name` (строка)
* `group` (строка, например `"A"` или `"B"`)
* `math` (целое 0–100)
* `python` (целое 0–100)
* `hours` (целое, сколько часов учился на неделе)
* `passed` (логическое `True/False`)
* `city` (строка)
* **и один пропуск**: у 1–2 студентов пусть `python` или `math` будет `None`

**Шаг 1.2.** Создай `df = pd.DataFrame(students)`.

**Шаг 1.3.** Выведи:

* первые 5 строк (`head`)
* информацию о столбцах и типах (`info`)
* базовую статистику (`describe`)

### 2) Доступ к данным: столбцы и строки

**Шаг 2.1.** Выведи столбцы `name`, `group`, `python` (одной командой).

**Шаг 2.2.** Выведи:

* строку с индексом 0 через `.iloc`
* строки со 2 по 5 (включительно) через `.iloc`

**Шаг 2.3.** Сделай столбец `name` индексом (через `set_index`), сохрани результат в `df2`.
Проверь, что теперь можно обратиться к конкретному студенту по имени через `.loc`.

### 3) Фильтрация

**Шаг 3.1.** Отфильтруй студентов, у кого `python >= 80`.
Сохрани в `top_python`.

**Шаг 3.2.** Отфильтруй студентов из группы `"A"` **и** с `math >= 70`.
Сохрани в `a_good_math`.

**Шаг 3.3.** Найди строки, где есть пропуски хотя бы в одной оценке (`math` или `python`).
Сохрани в `with_missing`.

### 4) Новые столбцы

**Шаг 4.1.** Создай столбец `avg_score` = среднее между `math` и `python`.
Важно: корректно обработай пропуски (чтобы среднее считалось по доступным значениям).

**Шаг 4.2.** Создай столбец `level`:

* `"high"`, если `avg_score >= 85`
* `"mid"`, если `70 <= avg_score < 85`
* `"low"`, если `avg_score < 70`

### 5) Группировка и агрегирование

**Шаг 5.1.** Посчитай по каждой `group`:

* среднее `avg_score`
* среднее `hours`
* количество студентов

Сохрани в `group_stats`.

**Шаг 5.2.** Посчитай, какой процент студентов `passed == True` в каждой группе.
(Можно как долю и умножить на 100.)

### 6) Сортировка и итоговая таблица

**Шаг 6.1.** Отсортируй `df` по `avg_score` по убыванию, сохрани в `rating`.

**Шаг 6.2.** Сформируй таблицу `final_view` только из столбцов:
`name`, `group`, `avg_score`, `level`, `hours`, `passed`
и выведи топ-5.

## Подсказки по ключевым частям

* **Пропуски (None/NaN):**

  * Проверка: `df.isna().sum()`
  * Среднее по двум колонкам с пропусками удобно так:
    `df[['math','python']].mean(axis=1, skipna=True)`

* **Фильтрация:**

  * И: `&`, Или: `|`
  * Скобки обязательны: `(df['group']=='A') & (df['math']>=70)`

* **Новый столбец level:**

  * Вариант 1: `np.select`
  * Вариант 2: функция + `.apply()` (помедленнее, но проще для старта)

* **Группировка:**

  * `df.groupby('group').agg(...)`
  * Количество строк: `'name': 'count'` или просто `.size()`

## Что проверить перед отправкой (чек-лист)

* [ ] `df.shape` показывает минимум 10 строк
* [ ] Есть хотя бы 1–2 пропуска в `math` или `python`
* [ ] `info()` выводится без ошибок
* [ ] Фильтры возвращают адекватные результаты (не пусто “случайно”)
* [ ] `avg_score` посчитан и **не ломается** из-за `NaN`
* [ ] `level` содержит только `high/mid/low` (проверь `value_counts()`)
* [ ] `group_stats` и процент `passed` считаются и имеют индекс по группам
* [ ] `rating` действительно отсортирован по убыванию
* [ ] `final_view.head(5)` выглядит логично

## Советы по улучшению работы

1. **Делай маленькие проверки после каждого шага**: `head()`, `value_counts()`, `isna().sum()`.
2. **Следи за типами**: оценки должны быть числом (`int`/`float`), `passed` — `bool`.
3. **Дай понятные имена переменным** (`top_python`, `group_stats`) — это сильно помогает читать код.
4. **Не бойся промежуточных таблиц**: проще дебажить, чем писать всё одной строкой.
5. Дополнительный бонус: сделай **функцию** `make_level(avg)` и используй её.
